java.util.HashMap.hash
```java
    static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
    }
```


在 Java 中，`>>>` 是一个**无符号右移运算符**（Unsigned Right Shift Operator），属于位运算符的一种。以下是详细解释：

### 核心特性
1. **操作对象**：只能用于整数类型（`byte`, `short`, `int`, `long`）。
2. **功能**：将操作数的二进制表示向右移动指定位数，**左侧空位永远补 0**（无论原数值正负）。
3. **结果类型**：
    - 若操作数是 `int`（或 `byte`/`short`，会自动提升为 `int`），结果为 `int`。
    - 若操作数是 `long`，结果为 `long`。

### 与 `>>`（有符号右移）的区别
| 运算符 | 名称         | 左侧空位填充规则         | 对负数的处理                     |
|--------|--------------|--------------------------|----------------------------------|
| `>>`   | 有符号右移   | 用原符号位填充（正数补0，负数补1） | 负数右移后仍是负数（保留符号） |
| `>>>`  | **无符号右移** | **永远补0**              | 负数右移后变为正数             |

### 示例代码
```java
// 示例1：正数（结果与 >> 相同）
int a = 16;       // 二进制: 00010000
int b = a >>> 2;  // 右移2位: 00000100 → 十进制 4
System.out.println(b); // 输出: 4

// 示例2：负数（关键区别！）
int c = -16;      // 二进制: 11111111 11111111 11111111 11110000
int d = c >>> 2;  // 右移2位: 00111111 11111111 11111111 11111100 → 正数
System.out.println(d); // 输出: 1073741820

// 对比有符号右移 >>
int e = c >> 2;   // 右移2位: 11111111 11111111 11111111 11111100 → 仍是负数 -4
System.out.println(e); // 输出: -4
```

### 关键注意事项
1. **对 `byte`/`short` 的自动提升**：
   ```java
   byte x = -8;    // 二进制: 11111000 (byte)
   int y = x >>> 2; // 先提升为 int: 11111111 11111111 11111111 11111000 → 右移后: 00111111 11111111 11111111 11111110
   System.out.println(y); // 输出: 1073741822
   ```
2. **移位位数取模**：
    - `int` 类型实际移位位数 = `n % 32`（如 `35 >>> 3` 等价于 `35 >>> (35 % 32) = 35 >>> 3`）。
    - `long` 类型实际移位位数 = `n % 64`。

### 典型应用场景
- **处理无符号数据**：如解析网络协议、文件格式时，需将二进制视为无符号数。
- **高位清零**：快速将指定位以上的数据清零（结合掩码使用）。
- **颜色处理/编码解码**：在图像处理中分离 RGB 通道。

### 总结
| 场景               | 推荐运算符 |
|--------------------|------------|
| 算术右移（保留符号） | `>>`       |
| **逻辑右移（补0）** | **`>>>`** |

理解 `>>>` 的关键在于记住它**强制忽略符号位**，右侧移出位丢弃，左侧空位一律补 0。这在处理无符号数据时非常有用！
