在 Java 中，`Comparable` 是一个重要的接口，用于定义对象的**自然排序**（natural ordering）。当一个类实现了 `Comparable` 接口，它就能与其他同类对象进行比较，并支持排序操作（如 `Collections.sort()` 或 `Arrays.sort()`）。

---

### 核心概念
1. **接口定义**：
   ```java
   public interface Comparable<T> {
       int compareTo(T o);
   }
   ```
   - 泛型 `<T>` 指定要比较的对象类型（通常是当前类自身）。
   - `compareTo()` 是必须实现的方法，用于定义比较逻辑。

2. **`compareTo()` 返回值规则**：
   - **负数**：当前对象 **小于** 目标对象（排在前面）
   - **零**：当前对象 **等于** 目标对象
   - **正数**：当前对象 **大于** 目标对象（排在后面）

---

### 实现步骤
以 `Student` 类为例，按分数（`score`）升序排序：
```java
public class Student implements Comparable<Student> {
    private String name;
    private int score;

    // 构造方法、Getter/Setter 省略

    @Override
    public int compareTo(Student other) {
        // 按 score 升序排序
        return this.score - other.score;
    }
}
```

---

### 使用场景
1. **排序集合/数组**：
   ```java
   List<Student> students = new ArrayList<>();
   students.add(new Student("Alice", 85));
   students.add(new Student("Bob", 75));
   
   Collections.sort(students); // 自动使用 compareTo() 排序
   ```

2. **有序数据结构**：
   ```java
   TreeSet<Student> treeSet = new TreeSet<>(); // 自动根据自然顺序排序
   treeSet.addAll(students);
   ```

---

### 关键规则
1. **自反性**：`x.compareTo(x) == 0`
2. **对称性**：若 `x.compareTo(y) > 0`，则 `y.compareTo(x) < 0`
3. **传递性**：若 `x.compareTo(y) > 0` 且 `y.compareTo(z) > 0`，则 `x.compareTo(z) > 0`
4. **一致性**：`x.compareTo(y) == 0` 时，`x.compareTo(z)` 与 `y.compareTo(z)` 符号相同
5. **强烈建议**：`x.compareTo(y) == 0` 应等价于 `x.equals(y)`（否则可能影响 `TreeSet` 等集合的行为）。

---

### 注意事项
1. **空值处理**：
   ```java
   @Override
   public int compareTo(Student other) {
       if (other == null) {
           throw new NullPointerException("Cannot compare to null");
       }
       return this.score - other.score;
   }
   ```

2. **多字段排序**（先按分数降序，分数相同按名字升序）：
   ```java
   @Override
   public int compareTo(Student other) {
       // 分数高的排在前面
       int scoreCompare = Integer.compare(other.score, this.score);
       if (scoreCompare != 0) {
           return scoreCompare;
       }
       // 分数相同时，按名字字典序排序
       return this.name.compareTo(other.name);
   }
   ```

3. **避免减法陷阱**（防止整数溢出）：
   ```java
   // 错误：可能溢出（如 this.score=Integer.MIN_VALUE, other.score=1）
   // return this.score - other.score;
   
   // 正确：使用 Integer.compare()
   return Integer.compare(this.score, other.score);
   ```

---

### `Comparable` vs `Comparator`
| 特性               | `Comparable`                          | `Comparator`                          |
|--------------------|---------------------------------------|---------------------------------------|
| **定义位置**       | 类内部（修改源码）                   | 外部类/匿名类/Lambda（无需修改源码） |
| **方法**           | `compareTo()`                         | `compare()`                           |
| **排序逻辑**       | 自然顺序（单一）                     | 自定义顺序（多种）                   |
| **使用场景**       | 默认排序规则                         | 临时或替代排序规则                   |
| **示例**           | `Collections.sort(list)`             | `Collections.sort(list, comparator)` |

---

### 最佳实践
- 若对象有**天然的顺序**（如数字、字符串、日期），优先实现 `Comparable`。
- 需要**多种排序方式**时，额外提供 `Comparator` 实现。
- 重写 `compareTo()` 时，**保持与 `equals()` 逻辑一致**（避免 `TreeSet` 等集合的混乱）。

通过实现 `Comparable`，你可以让 Java 的内置排序工具和集合类自动理解对象的顺序，大大简化排序相关的代码逻辑。
