在 Java 中，`ParameterizedType` 是 `java.lang.reflect` 包中的一个接口，用于表示带有**泛型参数的具体类型**（例如 `List<String>`）。它是 Java 反射机制的一部分，允许在运行时获取泛型类型的具体信息（绕过类型擦除的限制）。

### 核心概念
1. **类型擦除问题**：
    - Java 的泛型在编译后会被擦除（例如 `List<String>` 在运行时变成 `List`）。
    - `ParameterizedType` 通过反射保留了泛型的具体类型信息。

2. **关键方法**：
   ```java
   public interface ParameterizedType extends Type {
       // 获取实际类型参数（如 String 和 Integer）
       Type[] getActualTypeArguments();
   
       // 获取原始类型（如 Map）
       Type getRawType();
   
       // 获取所有者类型（内部类的场景，如 Map.Entry 的所有者是 Map）
       Type getOwnerType();
   }
   ```

### 使用场景示例
假设有以下类定义：
```java
public class MyClass {
    private List<String> stringList;
    private Map<Integer, String> integerMap;
}
```

#### 获取字段的泛型类型信息
```java
import java.lang.reflect.Field;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;

public class ReflectionExample {
    public static void main(String[] args) throws NoSuchFieldException {
        // 获取 List<String> 字段的泛型信息
        Field fieldList = MyClass.class.getDeclaredField("stringList");
        Type genericType = fieldList.getGenericType();

        if (genericType instanceof ParameterizedType) {
            ParameterizedType pt = (ParameterizedType) genericType;
            
            // 1. 获取原始类型：List.class
            Type rawType = pt.getRawType();
            System.out.println("Raw Type: " + rawType); // 输出: interface java.util.List
            
            // 2. 获取实际类型参数：[String.class]
            Type[] actualTypes = pt.getActualTypeArguments();
            for (Type actualType : actualTypes) {
                System.out.println("Actual Type: " + actualType); // 输出: class java.lang.String
            }
        }
    }
}
```

### 典型应用场景
1. **JSON 反序列化**（如 Gson/Jackson）：
   ```java
   Type type = new TypeToken<List<String>>() {}.getType(); // 内部使用 ParameterizedType
   List<String> list = gson.fromJson(jsonString, type);
   ```

2. **依赖注入框架**：解析带有泛型的字段或参数类型。

3. **自定义泛型处理器**：需要动态获取泛型参数时。

### 注意事项
1. **直接类无法获取**：
   ```java
   // 错误示例：类型擦除导致无法直接获取
   Class<?> listClass = List<String>.class; // 编译错误！
   ```

2. **获取泛型需通过间接方式**：
    - 字段（`Field.getGenericType()`）
    - 方法参数（`Method.getGenericParameterTypes()`）
    - 父类泛型（`Class.getGenericSuperclass()`）

### 完整示例：解析 Map<Integer, String>
```java
Field mapField = MyClass.class.getDeclaredField("integerMap");
Type mapType = mapField.getGenericType();

if (mapType instanceof ParameterizedType) {
    ParameterizedType pt = (ParameterizedType) mapType;
    
    System.out.println("Raw Type: " + pt.getRawType()); // java.util.Map
    
    Type[] actualTypes = pt.getActualTypeArguments();
    System.out.println("Key Type: " + actualTypes[0]); // java.lang.Integer
    System.out.println("Value Type: " + actualTypes[1]); // java.lang.String
}
```

### 总结
| 方法                     | 作用                          | 示例（`Map<Integer, String>`）       |
|--------------------------|-------------------------------|-------------------------------------|
| `getActualTypeArguments()` | 获取泛型参数的实际类型         | `[Integer.class, String.class]`     |
| `getRawType()`           | 获取原始类型（泛型容器）       | `Map.class`                         |
| `getOwnerType()`         | 获取所有者类型（内部类场景）   | 对于 `Map.Entry` 返回 `Map.class`   |

通过 `ParameterizedType`，开发者可以在运行时安全地操作泛型类型，解决类型擦除带来的限制，是高级反射和框架设计的核心工具之一。
