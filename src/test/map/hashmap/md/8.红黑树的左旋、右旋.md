# 树旋转：左旋与右旋详解

左旋和右旋是平衡二叉搜索树（如AVL树、红黑树）中用于维持平衡的基本操作。它们通过改变节点间的连接关系来调整树的高度，同时保持二叉搜索树的性质（左子树 < 根 < 右子树）。

## 左旋（Left Rotation）

### 操作定义
左旋是针对一个节点及其右子节点进行的操作：
1. **目标节点**：需要旋转的节点（设为X）
2. **支点节点**：X的右子节点（设为Y）

### 操作步骤
1. 将Y的左子树（β）变为X的右子树
2. 将X变为Y的左子树
3. 更新父节点引用

### 示意图
```
     X                  Y
    / \                / \
   α   Y     左旋→    X   γ
      / \            / \
     β   γ          α   β
```

### 代码实现（伪代码）
```java
void leftRotate(Node x) {
    Node y = x.right;   // 1. 获取x的右子节点y
    x.right = y.left;   // 2. 将y的左子树β作为x的右子树
    
    if (y.left != null) 
        y.left.parent = x; // 更新β的父节点
    
    y.parent = x.parent; // 3. 更新y的父节点
    
    if (x.parent == null) 
        root = y;       // x是根节点时
    else if (x == x.parent.left) 
        x.parent.left = y; // x是左子节点
    else 
        x.parent.right = y; // x是右子节点
    
    y.left = x;         // 4. 将x作为y的左子节点
    x.parent = y;       // 5. 更新x的父节点
}
```

### 适用场景
- 当右子树高度大于左子树时
- 需要降低右子树高度时
- 红黑树插入/删除后的平衡修复

## 右旋（Right Rotation）

### 操作定义
右旋是针对一个节点及其左子节点进行的操作：
1. **目标节点**：需要旋转的节点（设为Y）
2. **支点节点**：Y的左子节点（设为X）

### 操作步骤
1. 将X的右子树（β）变为Y的左子树
2. 将Y变为X的右子树
3. 更新父节点引用

### 示意图
```
       Y                X
      / \              / \
     X   γ   右旋→    α   Y
    / \                  / \
   α   β                β   γ
```

### 代码实现（伪代码）
```java
void rightRotate(Node y) {
    Node x = y.left;    // 1. 获取y的左子节点x
    y.left = x.right;   // 2. 将x的右子树β作为y的左子树
    
    if (x.right != null)
        x.right.parent = y; // 更新β的父节点
    
    x.parent = y.parent; // 3. 更新x的父节点
    
    if (y.parent == null)
        root = x;       // y是根节点时
    else if (y == y.parent.right)
        y.parent.right = x; // y是右子节点
    else
        y.parent.left = x;  // y是左子节点
    
    x.right = y;        // 4. 将y作为x的右子节点
    y.parent = x;       // 5. 更新y的父节点
}
```

### 适用场景
- 当左子树高度大于右子树时
- 需要降低左子树高度时
- 红黑树插入/删除后的平衡修复

## 关键特性

1. **保持二叉搜索树性质**：
   ``` 
   左旋前：α < X < β < Y < γ
   左旋后：α < X < β < Y < γ（不变）
   ```

2. **时间复杂度**：O(1) 常数时间操作

3. **高度调整**：
    - 左旋：降低右子树高度
    - 右旋：降低左子树高度

4. **局部性**：只影响旋转节点及其直接子节点，子树内部结构不变

## 实际应用示例（红黑树插入）

当插入节点导致"红-红冲突"时：
``` 
    黑(z)
   /
 红(y)   ← 新插入红(z)
/
红(z)
```

修复步骤：
1. 对y的父节点进行**右旋**
```
    红(y)
   /   \
 红(z) 黑(z)
```

2. 颜色调整（y变黑，z变红）

## 记忆技巧

1. **左旋口诀**：
   "右子变父，左孙变右"
    - 右子节点(Y)成为新父节点
    - 原来右子节点的左子树(β)成为原节点(X)的右子树

2. **右旋口诀**：
   "左子变父，右孙变左"
    - 左子节点(X)成为新父节点
    - 原来左子节点的右子树(β)成为原节点(Y)的左子树

## 可视化理解

初始状态：
```
      A
     / \
    B   C
       / \
      D   E
```

对A执行**左旋**：
```
      C
     / \
    A   E
   / \
  B   D
```

对C执行**右旋**（恢复原状）：
```
      A
     / \
    B   C
       / \
      D   E
```

## 工程意义

1. **平衡保证**：通过旋转维持O(log n)的操作复杂度
2. **高效更新**：旋转操作只修改少数指针
3. **算法基础**：是理解红黑树、AVL树等平衡树的核心
4. **数据库应用**：B+树的平衡也使用类似旋转思想

> **编程建议**：理解旋转操作时，建议用纸笔画出节点和指针的变化过程，这是掌握树平衡操作的关键。在实际实现中，需要特别注意指针更新的顺序，避免产生悬空引用。
